---
title: "Modern i18n DX in TanStack Start with Paraglide JS"
description: "A comprehensive guide to implementing type-safe internationalization in TanStack Start using Paraglide JS, covering everything from basic setup to advanced patterns."
pubDate: "Feb 08 2025"
heroImage: "/assets/paraglide-tanstack-start/image.png"
---

import { Note } from "../../components/Note";
import { Hint } from "../../components/Hint";
import { Video } from "../../components/Video";
import { Disclaimer } from "../../components/Disclaimer";

<Note>
  This guide uses Paraglide JS v2, which significantly simplifies the setup compared to v1. The built-in middleware and runtime functions eliminate the need for custom server functions and hooks that were required in earlier versions.
</Note>

## Why Paraglide?

While there are many i18n solutions available like react-i18next, FormatJS, and others, Paraglide JS stands out by offering a more modern, type-safe approach to internationalization. Here are the key benefits:

- **Type Safety**: Full TypeScript support with compile-time checks for missing translations and parameters
- **Performance**: Zero runtime overhead through compile-time optimizations and tree-shaking
- **Developer Experience**: Excellent IDE support with inline previews and real-time validation
- **Modern Tooling**: Part of the [inlang](https://inlang.com/) ecosystem with AI-powered suggestions and automated workflows

<Hint href="https://inlang.com/m/gerre34r/library-inlang-paraglideJs">
  Check out the official docs to learn more about what makes Paraglide unique
</Hint>

## Getting Started

Before diving into Paraglide, let's set up a fresh TanStack Start project. If you already have an existing project, just skip this.

First, create a new TanStack Start project using the official CLI:

```bash
npm create @tanstack/start@latest
```

For this guide, I've chosen a clean, minimal setup with Tailwind CSS and Biome as the toolchain, without any add-ons or examples. Feel free to adjust these options based on your preferences.

Once created, navigate to your project and start the dev server:

```bash
cd start-basic
npm run dev
```

<Hint href="https://tanstack.com/start/latest/docs/framework/react/quick-start">
  Check out TanStack's documentation for more setup options and configuration details
</Hint>

### Setting Up Paraglide

With our project ready, we can now add Paraglide. We'll set it up with English (`en`) and German (`de`) as our languages.

Run the initialization command:

```bash
npx @inlang/paraglide-js@latest init
```

The CLI will guide you through setup with several prompts:

1. **Uncommitted changes** - Recommends committing your work first (you can proceed anyway)
2. **Compiled files location** - Where to place generated files (default: `./src/paraglide`)
3. **TypeScript configuration** - Verifies `compilerOptions.allowJs: true` in `tsconfig.json`
4. **VS Code extension** - Adds Sherlock extension recommendation for inline translation previews
5. **Machine translations** - Enable AI-powered auto-translations (optional, we'll skip for manual control)

The init command automatically:
- Installs `@inlang/paraglide-js` to devDependencies
- Creates `project.inlang/` directory with your i18n configuration
- Creates `messages/` with example translation files (`en.json`, `de.json`)
- Adds the Vite plugin to `vite.config.ts`
- Compiles initial translations to the output directory

After initialization completes, you'll find the plugin added to `vite.config.ts`. To enable cookie-based language persistence and detection, update the plugin configuration with the following options:

```typescript
import { defineConfig } from 'vite'
import { tanstackStart } from '@tanstack/react-start/plugin/vite'
import viteReact from '@vitejs/plugin-react'
import { paraglideVitePlugin } from '@inlang/paraglide-js'

export default defineConfig({
  plugins: [
    paraglideVitePlugin({
      project: './project.inlang',
      outdir: './src/paraglide',
      outputStructure: 'message-modules',
      cookieName: 'PARAGLIDE_LOCALE',
      strategy: ['cookie', 'preferredLanguage', 'baseLocale'],
    }),
    tanstackStart(),
    viteReact(),
  ],
})
```

These configuration options enable:
- `outputStructure: 'message-modules'` - Cleaner import syntax for messages
- `cookieName: 'PARAGLIDE_LOCALE'` - Persists language selection across sessions
- `strategy: ['cookie', 'preferredLanguage', 'baseLocale']` - Language detection priority (cookie → browser preference → default)

<Note>
  By excluding "url" from the strategy array, we keep URLs clean without locale prefixes (e.g., `/about` instead of `/en/about`). This is ideal for applications where multi-locale SEO isn't a primary concern.
</Note>

### Creating Your First Translations

Paraglide uses a flat JSON structure for translations. The init command already created a `messages/` directory with example files. Let's customize them with our own messages.

Update `messages/en.json`:

```json
{
  "$schema": "https://inlang.com/schema/inlang-message-format",
  "hello": "Hello, world!",
  "greeting": "Hey {name}, how are you?"
}
```

Update `messages/de.json`:

```json
{
  "$schema": "https://inlang.com/schema/inlang-message-format",
  "hello": "Hallo, Welt!",
  "greeting": "Hey {name}, wie geht's dir?"
}
```

Parameters in curly braces (like `{name}`) become required function parameters in your TypeScript code, providing compile-time safety. The Vite plugin watches these files and automatically recompiles when you make changes.

<Hint href="https://inlang.com/m/gerre34r/library-inlang-paraglideJs/basics">
  Learn more about message parameters, pluralization, and advanced formatting in the official documentation
</Hint>

### Using Translations in Your Application

Now that we have our translations set up, let's create a new route to demonstrate how to use them. First, start your development server:

```bash
npm run dev
```

Create a new route file at `src/routes/hello.tsx`:

```tsx
import { createFileRoute } from '@tanstack/react-router'
import { m } from '@/paraglide/messages'

export const Route = createFileRoute('/hello')({
  component: HelloRoute,
})

function HelloRoute() {
  return (
    <div className="p-4">
      {/* Simple message without parameters */}
      <h1 className="text-2xl font-bold mb-4">{m.hello()}</h1>

      {/* Message with required parameter */}
      <p>{m.greeting({ name: 'Eugene' })}</p>
    </div>
  )
}
```

Thanks to Paraglide's type safety, your IDE will show errors if you:
- Try to use a message that doesn't exist
- Forget to provide required parameters
- Pass parameters with the wrong type

<Note>
  The `outputStructure: "message-modules"` option in our Vite config enables this clean import syntax. All your translations are available through the `m` object with full TypeScript support.
</Note>

### Configure Language Detection

Paraglide's Vite plugin generates server middleware that automatically handles language detection. The middleware checks for a saved language preference in cookies, falls back to the browser's language settings, and finally defaults to your base locale.

Create `src/server.ts` to set up the middleware:

```typescript
import { paraglideMiddleware } from './paraglide/server.js'
import handler from '@tanstack/react-start/server-entry'

export default {
  fetch(req: Request): Promise<Response> {
    return paraglideMiddleware(req, ({ request }) => handler.fetch(request))
  },
}
```

The middleware intercepts all requests and:
1. Reads the `PARAGLIDE_LOCALE` cookie if it exists
2. Falls back to the `Accept-Language` header from the browser
3. Defaults to your base locale (English in our case)

This happens automatically on every request, ensuring the correct language is always detected.

### Create Language Switcher

Now let's build a component that allows users to switch between languages. Create `src/components/LanguageSwitcher.tsx`:

```tsx
import { getLocale, locales, setLocale } from '@/paraglide/runtime'

export function LanguageSwitcher() {
  return (
    <div className="flex gap-2">
      {locales.map((locale) => (
        <button
          key={locale}
          onClick={() => setLocale(locale)}
          className={`px-3 py-1 rounded border ${
            locale === getLocale()
              ? 'bg-blue-500 text-white border-blue-600'
              : 'bg-gray-100 text-gray-700 border-gray-300 hover:bg-gray-200'
          }`}
        >
          {locale.toUpperCase()}
        </button>
      ))}
    </div>
  )
}
```

This component:
- Maps over all available `locales` from the Paraglide runtime
- Uses `getLocale()` to check which language is currently active
- Calls `setLocale(locale)` to switch languages (automatically updates the cookie)
- Highlights the active language with different styling

### Wire It All Together

Finally, update your root route to use the language switcher and set the HTML `lang` attribute. Update `src/routes/__root.tsx`:

```tsx
import { HeadContent, Scripts, createRootRoute } from '@tanstack/react-router'
import { TanStackRouterDevtoolsPanel } from '@tanstack/react-router-devtools'
import { TanStackDevtools } from '@tanstack/react-devtools'
import { getLocale } from '@/paraglide/runtime'

import { LanguageSwitcher } from '../components/LanguageSwitcher'

export const Route = createRootRoute({
  head: () => ({
    meta: [
      {
        charSet: 'utf-8',
      },
      {
        name: 'viewport',
        content: 'width=device-width, initial-scale=1',
      },
      {
        title: 'TanStack Start Starter',
      },
    ],
  }),
  shellComponent: RootDocument,
})

function RootDocument({ children }: { children: React.ReactNode }) {
  return (
    <html lang={getLocale()}>
      <head>
        <HeadContent />
      </head>
      <body>
        <div className="p-4 border-b">
          <LanguageSwitcher />
        </div>

        {children}

        <TanStackDevtools position="bottom-right" />
        <Scripts />
      </body>
    </html>
  )
}
```

Key points:
- `<html lang={getLocale()}>` dynamically sets the page language for accessibility and SEO
- The `LanguageSwitcher` is placed in the root layout, making it available on all pages
- When a user switches languages, `setLocale()` updates the cookie and triggers a re-render with the new language

That's it! Your application now has full language detection and switching capabilities with just a few lines of code.

## Enhancing DX

Now that we have our basic i18n setup working, let's improve our development experience with some powerful tools from the inlang ecosystem.

### VS Code Integration with Sherlock

To make working with translations easier and catch issues early, install the [Sherlock extension](https://marketplace.visualstudio.com/items?itemName=inlang.vs-code-extension) from VS Code marketplace. This extension provides real-time feedback and suggestions for your translations.

1. Install the Sherlock extension from the VS Code marketplace
2. Open your project in VS Code
3. The extension will automatically detect your inlang project configuration

<Note>
  If you don't see your project in the Sherlock inspector, try reloading VS Code
  (Cmd/Ctrl + Shift + P, then type "Reload Window").
</Note>

Once installed, you'll see inline previews of your translations directly in the code:

![Sherlock extension showing inline translation previews](/assets/paraglide-tanstack-start/inline-translations.png)

### Understanding Lint Rules

When you initialize a Paraglide project, it comes with several pre-installed lint rules out of the box:

export const RuleTable = ({ rules }) => (
  <div className="overflow-x-auto">
    <table className="min-w-full text-sm">
      <thead>
        <tr className="border-b">
          <th className="text-left py-2">Rule</th>
          <th className="text-left py-2">Description</th>
          <th className="text-left py-2">Example</th>
        </tr>
      </thead>
      <tbody>
        {rules.map((rule, i) => (
          <tr key={i} className="border-b last:border-0">
            <td className="py-2 font-medium">{rule.name}</td>
            <td className="py-2">{rule.description}</td>
            <td className="py-2 font-mono text-xs">{rule.example}</td>
          </tr>
        ))}
      </tbody>
    </table>
  </div>
);

<RuleTable
  rules={[
    {
      name: "Empty Pattern",
      description: "Flags empty string values",
      example: '"key": ""',
    },
    {
      name: "Missing Translation",
      description: "Flags keys missing in target languages",
      example: "missing 'greeting' in de.json",
    },
    {
      name: "Without Source",
      description: "Ensures translations exist in the source language (en)",
      example: "key exists in de.json but not in en.json",
    },
  ]}
/>

Let's add two additional lint rules to catch more translation issues:

<RuleTable
  rules={[
    {
      name: "Identical Pattern",
      description: "Flags identical translations across languages",
      example: '"greeting": "Hello" in both files',
    },
    {
      name: "Snake Case ID",
      description: "Enforces snake_case for message IDs",
      example: '"my_greeting" vs "myGreeting"',
    },
  ]}
/>

Update your `project.inlang.json`:

```json
{
  "$schema": "https://inlang.com/schema/project-settings",
  "sourceLanguageTag": "en",
  "languageTags": ["en", "de"],
  "modules": [
    // Pre-installed lint rules
    "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-empty-pattern@latest/dist/index.js",
    "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-missing-translation@latest/dist/index.js",
    "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-without-source@latest/dist/index.js",
    // Required plugins
    "https://cdn.jsdelivr.net/npm/@inlang/plugin-message-format@latest/dist/index.js",
    "https://cdn.jsdelivr.net/npm/@inlang/plugin-m-function-matcher@latest/dist/index.js",
    // Additional lint rules we're adding
    "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-identical-pattern@latest/dist/index.js",
    "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-snake-case-id@latest/dist/index.js"
  ],
  "plugin.inlang.messageFormat": {
    "pathPattern": "./messages/{languageTag}.json"
  }
}
```

### Seeing Lint Rules in Action

Let's intentionally break some lint rules to see how Sherlock helps us identify and fix issues. First, add these problematic translations to your message files.

In `messages/en.json`:

```json
{
  // ... existing translations ...
  "badTranslation": "This is a bad translation",
  "NOT_SNAKE_CASE": "",
  "identical_text": "Same text in both languages"
}
```

In `messages/de.json`:

```json
{
  // ... existing translations ...
  "identical_text": "Same text in both languages"
}
```

Now, let's use these translations in our route. Update `app/routes/hello-world.tsx`:

```tsx
import { createFileRoute } from "@tanstack/react-router";
import * as m from "../paraglide/messages";
import { LanguageSwitcher } from "../components/LanguageSwitcher";

export const Route = createFileRoute("/hello-world")({
  component: RouteComponent,
});

function RouteComponent() {
  return (
    <div className="p-4">
      <h1 className="text-2xl font-bold mb-4">{m.hello()}</h1>
      <p>{m.some_flat_other_key({ name: "Eugen" })}</p>

      {/* Adding our problematic translations */}
      <div className="mt-4">
        <p>{m.badTranslation()}</p>
        <p>{m.NOT_SNAKE_CASE()}</p>
        <p>{m.identical_text()}</p>
      </div>

      <div className="mt-4">
        <LanguageSwitcher />
      </div>
    </div>
  );
}
```

You should now see several lint errors in your IDE:

![Sherlock showing lint errors in the translation files](/assets/paraglide-tanstack-start/lint-errors.png)

Let's fix these issues one by one:

<Video src="/assets/paraglide-tanstack-start/fixes.mp4" />

I think this is quite nice DX. Having all those errors etc. makes it harder to
make mistakes.

## Limitations and Considerations

While Paraglide JS offers many advantages, it has some limitations to consider:

- **Runtime Flexibility**: Translations are compiled at build time, so dynamic loading isn't possible. This mainly affects content-heavy sites like blogs or e-commerce platforms that need translations from a database or CMS. Most CMSs have their own translation systems you can use instead.
- **Ecosystem Maturity**: Being newer than alternatives, some advanced features are still in development. Version 2 will add pluralization and gender support, and the ecosystem is actively growing with regular updates.
- **Build Time Overhead**: The compilation step adds a small build overhead, though it's usually negligible.

## Wrapping Up

Throughout this guide, we've explored integrating Paraglide JS with TanStack Start to create a modern, type-safe internationalization system. We've covered:

- Setting up Paraglide JS in a TanStack Start project
- Creating and managing translations with full type safety
- Implementing language detection and switching
- Leveraging VS Code extensions for better DX
- Understanding and working with lint rules

Paraglide JS stands out for its strong developer experience, type safety, and performance - key features for modern React projects. Its compile-time optimizations and tooling support make it particularly effective for teams building maintainable applications.

If you're starting a new project or looking to modernize your i18n setup, give Paraglide JS a try.

### Useful Resources

- [Full source code for this guide](https://github.com/EugenEistrach/paraglide-tanstack-start)
- [Paraglide JS Documentation](https://inlang.com/m/gerre34r/library-inlang-paraglideJs)
- [TanStack Start Documentation](https://tanstack.com/start)
- [Inlang GitHub Repository](https://github.com/inlang/inlang)
- [VS Code Sherlock Extension](https://marketplace.visualstudio.com/items?itemName=inlang.vs-code-extension)
